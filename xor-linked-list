XorLinkedList = class XorLinkedList {
  static NOT_FOUND = 0xffff_ffff;
  static NULL_PTR = 0;
  static INITIAL_CAPACITY = 7;
  static MAX_CAPACITY = 0x3ff_ffff;
  static ELEMENT_SIZE = 2;
  static VALUE_OFFSET = 0;
  static NEXT_OFFSET = 1;

  constructor() {
    this.capacity = XorLinkedList.INITIAL_CAPACITY;
    this.size = 0;
    this.head = XorLinkedList.NOT_FOUND;
    this.tail = XorLinkedList.NOT_FOUND;
    this.buffer = new Uint32Array(this.capacity * XorLinkedList.ELEMENT_SIZE);
  }

  get length() {
    return this.size;
  }

  first() {
    return this.head;
  }

  last() {
    return this.tail;
  }

  isEmpty() {
    return this.size === 0;
  }

  *[Symbol.iterator]() {
    let prev = XorLinkedList.NOT_FOUND;
    let current = this.head;
    while (current != XorLinkedList.NOT_FOUND) {
      yield this.buffer[current + XorLinkedList.VALUE_OFFSET];
      let next = (prev ^ this.buffer[current + XorLinkedList.NEXT_OFFSET]) >>> 0;
      prev = current;
      current = next;
    }
  }

  allocate(value, address) {
    this.ensureCapacity(this.size + 1);
    let newAddress = XorLinkedList.ELEMENT_SIZE * this.size++;
    this.buffer[newAddress + XorLinkedList.VALUE_OFFSET] = value;
    this.buffer[newAddress + XorLinkedList.NEXT_OFFSET] = address;
    return newAddress;
  }

  ensureCapacity(size) {
    if (size > XorLinkedList.MAX_CAPACITY)
      throw new Error("Unable to allocate memory.");
    if (size <= this.capacity) return;
    while (size > this.capacity)
      this.capacity = Math.min(XorLinkedList.MAX_CAPACITY, this.capacity * 2 + 1);
    this.buffer = new Uint32Array(this.buffer.buffer.transfer(
      Uint32Array.BYTES_PER_ELEMENT * XorLinkedList.ELEMENT_SIZE * this.capacity));
  }

  append(value) {
    const newAddress = this.allocate(value, (this.tail ^ XorLinkedList.NOT_FOUND) >>> 0);
    if (this.size === 1) {
      this.head = newAddress;
    } else {
      this.buffer[this.tail + XorLinkedList.NEXT_OFFSET] ^= (XorLinkedList.NOT_FOUND ^ newAddress);
    }
    return this.tail = newAddress;
  }

  prepend(value) {
    const newAddress = this.allocate(value, (this.head ^ XorLinkedList.NOT_FOUND) >>> 0);
    if (this.size === 1) {
      this.tail = newAddress;
    } else {
      this.buffer[this.head + XorLinkedList.NEXT_OFFSET] ^= (XorLinkedList.NOT_FOUND ^ newAddress);
    }
    return this.head = newAddress;
  }

  checkAddress(address) {
    if (address === XorLinkedList.NOT_FOUND) return;
    if (address >= this.size * XorLinkedList.ELEMENT_SIZE || address % XorLinkedList.ELEMENT_SIZE != XorLinkedList.VALUE_OFFSET) {
      throw new Error(`Invalid address ${address}.`);
    }
  }

  get(address) {
    this.checkAddress(address);
    return this.buffer[address + XorLinkedList.VALUE_OFFSET];
  }

  addressOf(value) {
    let prev = XorLinkedList.NOT_FOUND;
    let current = this.head;
    while (current != XorLinkedList.NOT_FOUND) {
      if (this.buffer[current + XorLinkedList.VALUE_OFFSET] === value) {
        return current;
      }
      let next = (prev ^ this.buffer[current + XorLinkedList.NEXT_OFFSET]) >>> 0;
      prev = current;
      current = next;
    }
    return XorLinkedList.NOT_FOUND;
  }

  insertBetween(value, address1, address2) {
    this.checkAddress(address1);
    this.checkAddress(address2);
    if (address1 === XorLinkedList.NOT_FOUND) {
      return this.prepend(value);
    } else if (address2 === XorLinkedList.NOT_FOUND) {
      return this.append(value);
    };

    let newAddress = this.allocate(value, (address1 ^ address2) >>> 0);

    this.buffer[address1 + XorLinkedList.NEXT_OFFSET] ^= (address2 ^ newAddress);
    this.buffer[address2 + XorLinkedList.NEXT_OFFSET] ^= (address1 ^ newAddress);

    return newAddress;
  }

  reverse() {
    [this.head, this.tail] = [this.tail, this.head];
    return this;
  }
}

module.exports = XorLinkedList;